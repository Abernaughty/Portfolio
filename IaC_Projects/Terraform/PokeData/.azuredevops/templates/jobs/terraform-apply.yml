# Template for Terraform Apply
parameters:
  - name: workingDirectory
    type: string
  - name: terraformVersion
    type: string
  - name: environment
    type: string
  - name: artifactName
    type: string

steps:
  - checkout: self
    persistCredentials: true

  - task: TerraformInstaller@1
    displayName: 'Install Terraform latest'
    inputs:
      terraformVersion: latest

  # Re-init so provider plugins/backends exist in this fresh job workspace
  - task: TerraformTaskV4@4
    displayName: 'Terraform Init (Apply)'
    inputs:
      provider: 'azurerm'
      command: 'init'
      workingDirectory: '${{ parameters.workingDirectory }}'
      backendServiceArm: '$(azureServiceConnection)'
      backendAzureRmResourceGroupName: 'pokedata-terraform-state-rg'
      backendAzureRmStorageAccountName: 'tfstateyul4ts'
      backendAzureRmContainerName: 'tfstate-${{ parameters.environment }}'
      backendAzureRmKey: 'pokedata/${{ parameters.environment }}.tfstate'
    env:
      TF_VAR_repository_token: $(github_token)   # secret from variable group / Key Vault

  # Pull the saved plan artifact produced in the Plan stage
  - task: DownloadBuildArtifacts@1
    displayName: 'Download Terraform Plan'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: '${{ parameters.artifactName }}'
      downloadPath: '$(Agent.TempDirectory)'

  # Place tfplan next to the code for a simple relative apply
  - task: PowerShell@2
    displayName: 'Restore Plan File'
    inputs:
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        $src = Join-Path "$(Agent.TempDirectory)" "${{ parameters.artifactName }}\tfplan"
        $dst = Join-Path "${{ parameters.workingDirectory }}" "tfplan"
        Write-Host "Copying plan: $src -> $dst"

        if (-not (Test-Path $src)) {
          throw "Plan artifact not found at $src. Check that the Plan stage published the artifact named '${{ parameters.artifactName }}' and that you're downloading it in Apply."
        }

        Copy-Item -LiteralPath $src -Destination $dst -Force
        if (-not (Test-Path $dst)) { throw "Failed to copy plan to $dst" }
        Write-Host "‚úÖ Terraform plan file restored at $dst"

  # Apply the exact plan reviewed earlier (no -var-file here)
  - task: TerraformTaskV4@4
    displayName: 'Terraform Apply'
    inputs:
      provider: 'azurerm'
      command: 'apply'
      workingDirectory: '${{ parameters.workingDirectory }}'
      commandOptions: '-input=false -auto-approve tfplan'
      environmentServiceNameAzureRM: '$(azureServiceConnection)'
    env:
      TF_VAR_repository_token: $(github_token)

  # Extract Terraform Outputs as Pipeline Variables
  - task: PowerShell@2
    displayName: 'Extract Terraform Outputs for Pipeline Variables'
    name: setOutputs
    env:
      TF_VAR_repository_token: $(github_token)
    inputs:
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        # Use Continue for graceful error handling in try-catch blocks
        $ErrorActionPreference = 'Continue'
        $env:TF_IN_AUTOMATION = "true"
        
        Write-Host "=== EXTRACTING TERRAFORM OUTPUTS FOR PIPELINE VARIABLES ===" -ForegroundColor Cyan
        Write-Host ""
        
        # Track if we successfully extract required variables
        $requiredVariablesExtracted = $true
        
        # Extract connection strings for Function App deployment
        try {
          # REQUIRED: Cosmos DB connection string
          Write-Host "Extracting Cosmos DB connection string..." -ForegroundColor Yellow
          $cosmosConnection = terraform output -raw cosmos_db_connection_string 2>$null
          if ([string]::IsNullOrWhiteSpace($cosmosConnection)) {
            Write-Host "‚ùå ERROR: Cosmos DB connection string is empty - this is required" -ForegroundColor Red
            $requiredVariablesExtracted = $false
          } else {
            Write-Host "‚úì Cosmos DB connection string extracted" -ForegroundColor Green
            Write-Host "##vso[task.setvariable variable=COSMOS_CONNECTION;isOutput=true;isSecret=true]$cosmosConnection"
          }
          
          # REQUIRED: Function App name for deployment
          Write-Host "Extracting Function App name..." -ForegroundColor Yellow
          $functionAppName = terraform output -raw function_app_name 2>$null
          if ([string]::IsNullOrWhiteSpace($functionAppName)) {
            Write-Host "‚ùå ERROR: Function App name is empty - this is required for deployment" -ForegroundColor Red
            $requiredVariablesExtracted = $false
          } else {
            Write-Host "‚úì Function App name extracted: $functionAppName" -ForegroundColor Green
            Write-Host "##vso[task.setvariable variable=FUNCTION_APP_NAME;isOutput=true]$functionAppName"
          }
          
          # OPTIONAL: Application Storage Account (for blob storage features)
          Write-Host "Checking for application Storage Account connection string..." -ForegroundColor Yellow
          $blobConnection = $null
          try {
            $blobConnection = terraform output -raw blob_storage_connection_string 2>$null
            if ($LASTEXITCODE -ne 0) { $blobConnection = $null }
          } catch {
            $blobConnection = $null
          }
          
          if (-not [string]::IsNullOrWhiteSpace($blobConnection)) {
            Write-Host "‚úì Application Storage Account connection string extracted" -ForegroundColor Green
            Write-Host "##vso[task.setvariable variable=BLOB_CONNECTION;isOutput=true;isSecret=true]$blobConnection"
            Write-Host "##vso[task.setvariable variable=HAS_BLOB_STORAGE;isOutput=true]true"
          } else {
            Write-Host "‚ö†Ô∏è Application Storage Account not deployed - skipping blob storage configuration" -ForegroundColor Yellow
            Write-Host "##vso[task.setvariable variable=HAS_BLOB_STORAGE;isOutput=true]false"
          }
          
          # OPTIONAL: Redis Cache (for caching features)
          Write-Host "Checking for Redis Cache connection string..." -ForegroundColor Yellow
          $redisConnection = $null
          try {
            $redisConnection = terraform output -raw redis_connection_string 2>$null
            if ($LASTEXITCODE -ne 0) { $redisConnection = $null }
          } catch {
            $redisConnection = $null
          }
          
          if (-not [string]::IsNullOrWhiteSpace($redisConnection)) {
            Write-Host "‚úì Redis Cache connection string extracted" -ForegroundColor Green
            Write-Host "##vso[task.setvariable variable=REDIS_CONNECTION;isOutput=true;isSecret=true]$redisConnection"
            Write-Host "##vso[task.setvariable variable=HAS_REDIS_CACHE;isOutput=true]true"
          } else {
            Write-Host "‚ö†Ô∏è Redis Cache not deployed - skipping cache configuration" -ForegroundColor Yellow
            Write-Host "##vso[task.setvariable variable=HAS_REDIS_CACHE;isOutput=true]false"
          }
          
          # Check if all required variables were extracted successfully
          if (-not $requiredVariablesExtracted) {
            Write-Host ""
            Write-Host "‚ùå ERROR: Failed to extract required Terraform outputs" -ForegroundColor Red
            Write-Host ""
            Write-Host "Available Terraform outputs:" -ForegroundColor Yellow
            terraform output
            exit 1
          }
          
          Write-Host ""
          Write-Host "=== PIPELINE VARIABLES SET SUCCESSFULLY ===" -ForegroundColor Green
          Write-Host "‚úì COSMOS_CONNECTION (sensitive) - REQUIRED" -ForegroundColor Green
          Write-Host "‚úì FUNCTION_APP_NAME: $functionAppName - REQUIRED" -ForegroundColor Green
          Write-Host "‚úì BLOB_CONNECTION (sensitive) - OPTIONAL" -ForegroundColor Green
          Write-Host "‚úì REDIS_CONNECTION (sensitive) - OPTIONAL" -ForegroundColor Green
          Write-Host ""
          Write-Host "These variables are now available for the Function App deployment stage." -ForegroundColor Cyan
          
        } catch {
          Write-Host "‚ùå ERROR: Unexpected error during Terraform output extraction" -ForegroundColor Red
          Write-Host "Error details: $($_.Exception.Message)" -ForegroundColor Red
          Write-Host ""
          Write-Host "Available Terraform outputs:" -ForegroundColor Yellow
          terraform output
          exit 1
        }

  # Generate Deployment Summary  
  - task: PowerShell@2
    displayName: 'Generate Deployment Summary'
    env:
      TF_VAR_repository_token: $(github_token)
    inputs:
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        $ErrorActionPreference = 'Stop'
        $env:TF_IN_AUTOMATION = "true"

        $file = "deployment-summary.md"
        $lines = @()
        $lines += "## Deployment Summary for ${{ parameters.environment }}"
        $lines += ""
        $lines += "**Environment:** ${{ parameters.environment }}"
        $lines += "**Build:** $(Build.BuildNumber)"
        $lines += "**Deployed by:** $(Build.RequestedFor)"
        $lines += "**Deployment Time:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz')"
        $lines += ""
        $lines += "### Terraform Outputs:"
        Set-Content -Path $file -Value $lines -Encoding utf8

        terraform output -json | Out-File -FilePath "outputs.json" -Encoding utf8
        terraform output       | Out-File -FilePath $file -Append -Encoding utf8

        Add-Content -Path $file -Value ""
        Add-Content -Path $file -Value "‚úÖ Infrastructure successfully deployed to ${{ parameters.environment }}"

        Get-Content $file | Write-Host

  # Publish artifacts
  - task: PublishBuildArtifacts@1
    displayName: 'Publish Deployment Summary'
    inputs:
      pathToPublish: '${{ parameters.workingDirectory }}/deployment-summary.md'
      artifactName: 'deployment-summary-${{ parameters.environment }}'
      publishLocation: 'Container'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Terraform Outputs'
    inputs:
      pathToPublish: '${{ parameters.workingDirectory }}/outputs.json'
      artifactName: 'terraform-outputs-${{ parameters.environment }}'
      publishLocation: 'Container'

  # Tag Deployment (optional)
  - script: |
      git config user.email "azure-pipeline@maber.io"
      git config user.name "Azure Pipeline"
      $TAG_NAME="${{ parameters.environment }}-$(Build.BuildNumber)"
      git tag -a "$TAG_NAME" -m "Deployed to ${{ parameters.environment }} by $(Build.RequestedFor)"
      git push origin "$TAG_NAME" || echo "Could not push tag (no permissions)"
      echo "‚úÖ Deployment tagged as: $TAG_NAME"
    displayName: 'Tag Deployment'
    continueOnError: true

  # Deployment Complete (move workingDirectory under inputs)
  - task: PowerShell@2
    displayName: 'Deployment Complete'
    inputs:
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        Write-Host "üéâ Deployment to ${{ parameters.environment }} completed successfully!"
        Write-Host ""
        Write-Host "Resources deployed:"
        terraform state list
