# Template for Terraform Apply
parameters:
  - name: workingDirectory
    type: string
  - name: terraformVersion
    type: string
  - name: environment
    type: string
  - name: artifactName
    type: string

steps:
  - checkout: self
    persistCredentials: true

  - task: TerraformInstaller@1
    displayName: 'Install Terraform latest'
    inputs:
      terraformVersion: latest

  # Re-init so provider plugins/backends exist in this fresh job workspace
  - task: TerraformTaskV4@4
    displayName: 'Terraform Init (Apply)'
    inputs:
      provider: 'azurerm'
      command: 'init'
      workingDirectory: '${{ parameters.workingDirectory }}'
      backendServiceArm: '$(azureServiceConnection)'
      backendAzureRmResourceGroupName: 'pokedata-terraform-state-rg'
      backendAzureRmStorageAccountName: 'tfstateyul4ts'
      backendAzureRmContainerName: 'tfstate-${{ parameters.environment }}'
      backendAzureRmKey: 'pokedata/${{ parameters.environment }}.tfstate'
    env:
      TF_VAR_repository_token: $(github_token)   # secret from variable group / Key Vault

  # Pull the saved plan artifact produced in the Plan stage
  - task: DownloadBuildArtifacts@1
    displayName: 'Download Terraform Plan'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: '${{ parameters.artifactName }}'
      downloadPath: '$(Agent.TempDirectory)'

  # Place tfplan next to the code for a simple relative apply
  - task: PowerShell@2
    displayName: 'Restore Plan File'
    inputs:
      pwsh: true
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        $src = Join-Path "$(Agent.TempDirectory)" "${{ parameters.artifactName }}\tfplan"
        $dst = Join-Path "${{ parameters.workingDirectory }}" "tfplan"
        Write-Host "Copying plan: $src -> $dst"

        if (-not (Test-Path $src)) {
          throw "Plan artifact not found at $src. Check that the Plan stage published the artifact named '${{ parameters.artifactName }}' and that you're downloading it in Apply."
        }

        Copy-Item -LiteralPath $src -Destination $dst -Force
        if (-not (Test-Path $dst)) { throw "Failed to copy plan to $dst" }
        Write-Host "âœ… Terraform plan file restored at $dst"

  # Apply the exact plan reviewed earlier (no -var-file here)
  - task: TerraformTaskV4@4
    displayName: 'Terraform Apply'
    inputs:
      provider: 'azurerm'
      command: 'apply'
      workingDirectory: '${{ parameters.workingDirectory }}'
      commandOptions: '-input=false -auto-approve tfplan'
      environmentServiceNameAzureRM: '$(azureServiceConnection)'
    env:
      TF_VAR_repository_token: $(github_token)

  # Extract Terraform Outputs as Pipeline Variables
  - task: PowerShell@2
    displayName: Extract Terraform outputs for pipeline variables
    name: setOutputs             # <-- required to reference output vars
    env:
      TF_VAR_repository_token: $(github_token)
    inputs:
      pwsh: true
      targetType: inline
      workingDirectory: ${{ parameters.workingDirectory }}
      script: |
        $ErrorActionPreference = 'Stop'
        $env:TF_IN_AUTOMATION = 'true'

        Write-Host "=== EXTRACTING TERRAFORM OUTPUTS ==="
        $json = terraform output -json
        $outs = $json | ConvertFrom-Json

        function Get-OutVal {
          param([object]$Obj,[string]$Name)
          if ($Obj.PSObject.Properties.Name -contains $Name) {
            $v = $Obj.$Name.value
            if ($null -ne $v) { return [string]$v }
          }
          return $null
        }

        $cosmos   = Get-OutVal $outs 'cosmos_db_connection_string'
        $funcApp  = Get-OutVal $outs 'function_app_name'
        $blob     = Get-OutVal $outs 'blob_storage_connection_string'
        $redis    = Get-OutVal $outs 'redis_connection_string'

        $missing = @()
        if ([string]::IsNullOrWhiteSpace($cosmos))  { $missing += 'cosmos_db_connection_string' }
        if ([string]::IsNullOrWhiteSpace($funcApp)) { $missing += 'function_app_name' }

        if ($cosmos)  { Write-Host "##vso[task.setvariable variable=COSMOS_CONNECTION;isOutput=true;isSecret=true]$cosmos" }
        if ($funcApp) { Write-Host "##vso[task.setvariable variable=FUNCTION_APP_NAME;isOutput=true]$funcApp" }
        if ($blob)    { Write-Host "##vso[task.setvariable variable=BLOB_CONNECTION;isOutput=true;isSecret=true]$blob" }
        if ($redis)   { Write-Host "##vso[task.setvariable variable=REDIS_CONNECTION;isOutput=true;isSecret=true]$redis" }

        Write-Host "##vso[task.setvariable variable=HAS_BLOB_STORAGE;isOutput=true]$([bool]$blob)"
        Write-Host "##vso[task.setvariable variable=HAS_REDIS_CACHE;isOutput=true]$([bool]$redis)"

        if ($missing.Count -gt 0) {
          Write-Host "##vso[task.logissue type=error]Missing required outputs: $($missing -join ', ')"
          Write-Host "##vso[task.complete result=Failed;]"
          exit 1
        }

        Write-Host "=== PIPELINE VARIABLES SET SUCCESSFULLY ==="
        exit 0

  # Generate Deployment Summary  
  - task: PowerShell@2
    displayName: 'Generate Deployment Summary'
    env:
      TF_VAR_repository_token: $(github_token)
    inputs:
      pwsh: true
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        $ErrorActionPreference = 'Stop'
        $env:TF_IN_AUTOMATION = "true"

        $file = "deployment-summary.md"
        $lines = @()
        $lines += "## Deployment Summary for ${{ parameters.environment }}"
        $lines += ""
        $lines += "**Environment:** ${{ parameters.environment }}"
        $lines += "**Build:** $(Build.BuildNumber)"
        $lines += "**Deployed by:** $(Build.RequestedFor)"
        $lines += "**Deployment Time:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz')"
        $lines += ""
        $lines += "### Terraform Outputs:"
        Set-Content -Path $file -Value $lines -Encoding utf8

        terraform output -json | Out-File -FilePath "outputs.json" -Encoding utf8
        terraform output       | Out-File -FilePath $file -Append -Encoding utf8

        Add-Content -Path $file -Value ""
        Add-Content -Path $file -Value "âœ… Infrastructure successfully deployed to ${{ parameters.environment }}"

        Get-Content $file | Write-Host

  # Publish artifacts
  - task: PublishBuildArtifacts@1
    displayName: 'Publish Deployment Summary'
    inputs:
      pathToPublish: '${{ parameters.workingDirectory }}/deployment-summary.md'
      artifactName: 'deployment-summary-${{ parameters.environment }}'
      publishLocation: 'Container'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Terraform Outputs'
    inputs:
      pathToPublish: '${{ parameters.workingDirectory }}/outputs.json'
      artifactName: 'terraform-outputs-${{ parameters.environment }}'
      publishLocation: 'Container'

  # Tag Deployment (optional)
  - script: |
      git config user.email "azure-pipeline@maber.io"
      git config user.name "Azure Pipeline"
      $TAG_NAME="${{ parameters.environment }}-$(Build.BuildNumber)"
      git tag -a "$TAG_NAME" -m "Deployed to ${{ parameters.environment }} by $(Build.RequestedFor)"
      git push origin "$TAG_NAME" || echo "Could not push tag (no permissions)"
      echo "âœ… Deployment tagged as: $TAG_NAME"
    displayName: 'Tag Deployment'
    continueOnError: true

  # Deployment Complete (move workingDirectory under inputs)
  - task: PowerShell@2
    displayName: 'Deployment Complete'
    inputs:
      pwsh: true
      targetType: inline
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        Write-Host "ðŸŽ‰ Deployment to ${{ parameters.environment }} completed successfully!"
        Write-Host ""
        Write-Host "Resources deployed:"
        terraform state list